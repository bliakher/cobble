# Cobble {#mainpage}

Dobble game for one player written in C++


## Rules of the game

The game is played with a deck of cards. On each card there are different symbols. Any two cards have **exactly one** one symbol in common. The objective of the game is to find this common symbol.

In the game there is a deck of cards on the left side and one card on the right side, turned symbol side up. Player must find the common symbol between the two cards and click on it. If player found the correct symbol, the top card from the deck is moved to the right pile, revealing the next card from the deck. Game continues until all cards from the deck are used or until the time limit ends. Time limit for one game is 1 minute.

At the start of the game player has 3 lives. If the player makes a mistake, they lose one life. The card is not moved until the symbol is found correctly. If the player runs out of lives, game ends.

The player is awarded points for finding the right symbol quickly and penalised for making mistakes.

## Configuration

Pictures used in the game and the amount of symbols per card can be configured.

If you want to have `c` symbols per card:
- `n = c - 1`
- `n` must be prime for the game to work
- you will need to provide `n^2 + n + 1` pictures
- the game will contain `n^2 + n + 1` different cards

For example, if you want to have 4 symbols per card (4 - 1 = 3 is prime), you will need 13 (3^2 + 3 + 1 = 13) different pictures and the game will have 13 cards.

Ideally, pictures should be in `PNG` format with transparent background.

There are 13 pictures already provided with the game (in directory `cobble_src/data/pictures`), so it is possible to play 2 versions of the game:
- 3 symbols per card, 7 cards total
- 4 symbols per card, 13 cards total

You can configure the game with command line arguments.
- `-i <path>` sets the path to the directory containing pictures for the game
- `-c <number>` sets the number of symbols per card

It is sufficient to run the command only once, your choices are saved for future games. The default values are `-i ./data/pictures -c 4`.

## Implementation

### Mathematical base

Cards and symbols in the game are based on finite projective planes. 
Projective plane that has an order n has (n^2 + n + 1) points and the same amount of lines.
Points are split between the lines so that any 2 points define a line and any 2 lines intersect at exactly 1 point.
Based on the rules, the size of the line (the number of points on that line) is always (n + 1)

We use the projective plane as a base for the game to enforce that any 2 cards in the game have exactly one common symbol.
To create a deck of cards for the game we generate a projective plane of appropriate size based on how many symbols we want on one card.
Then we use points in the plain to act as symbols in the game and then the lines, 
which act as cards, tell us which symbols to put on each card.

To generate the projective plane for the game I used a method which can only work for planes where the order n is a prime number.
This means that only a game, which has (n + 1) symbols on the cards where n is prime, can be generated by the program.

### Dependencies

I decided to use the [SDL2 library](https://www.libsdl.org) as the game development framework in this project.
The library provides access to graphics and also keyboard and mouse. 
I chose this library because I am already familiar with the Pygame library, 
which is based on SDL, so the main concepts are very similar.

I also used some extension libraries, namely [SDL_image](https://www.libsdl.org/projects/SDL_image/) for loading images from files,
[SDL_gfx](https://www.ferzkopp.net/wordpress/2016/01/02/sdl_gfx-sdl2_gfx/) for drawing graphical primitives and for scaling and rotating images
and [SDL_ttf](https://github.com/libsdl-org/SDL_ttf) for working with fonts.

### Architecture

The main object in the project is the `Game` class. 
It has a state based on the stage of the game, and it also tracks the number of points and lives that the player has.
It contains the current `GameScreen` displayed to the player. 
There are different kinds of screens according to the stage of the game - `IntroScreen`, `PlayScreen` and `OutroScreen`.
All kinds of screens inherit from the `GameScreen` class, so they all have the `Draw` method and the `UpdateOnClick` method.

There is also a part responsible for creating the card deck for the game. 
`ProjectivePlane` is a class that represents a projective plane, which is a base for the card deck.
According to the size of the plane the `ImageLoader` object loads images from files.
Images are then combined based on the `ProjectivePlane` object to create `Card` objects.
Cards are grouped into a `Deck`.

The game deck is created in line with the user configuration.
`ArgParser` manages the user configuration taken from the command line arguments and from cache.
It provides the path to the directory with user images, that should be used in the game, 
and the desirable amount of symbols per card.

Everything is connected in the main function, where the user configuration is read, 
then the images are loaded and the `Game` object created.
In each frame, the current screen inside the `Game` object is drawn.
Game is then updated based on incoming events.